<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:batch="http://www.springframework.org/schema/batch"
       xsi:schemaLocation="
       http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--导入job的上下文配置-->
    <!--<import resource="classpath:/job/job-context.xml" />-->

    <!--抽象job-->
    <batch:job id="abstractJob" abstract="true">
        <batch:listeners><batch:listener ref="systemOut" /></batch:listeners>
    </batch:job>

    <!--定义作业的名字，由多个job组成，封装整个批处理操作-->
    <batch:job id="billJob" parent="abstractJob">
    <!--<batch:job id="billJob" restartable="true">--><!--job的唯一标识，在整个运行上下文中不运行重复，job-repository 默认使用名为jobRepository，restartable 表示当前作业是否支持重启，默认true-->
        <!--incrementer作业参数递增器，只有在JobOperator的startNextnIcrementer方法中使用，parent 指定当前job继承其他Job，abstract使用true表示当前job是否抽象，不能实例-->
        <batch:description>第一个测试例子</batch:description>
        <batch:step id="billStep"><!--定义一个作业步--><!--Job的一个执行环节，可以定义具体执行逻辑-->
            <!--tasklet定义step具体执行逻辑操作，可以重复执行，可设置同步，异步等-->
            <batch:tasklet transaction-manager="transactionManager"><!--指定负责批处理处理的事务管理器-->
                <!--chunk 给定数量Item的集合，可以定义读，处理，写操作，提交间隔.......-->
                <!--commit-interval表示提交间隔大小，本例子表示每处理两条写入一次-->
                <batch:chunk reader="csvItemReader" writer="csvItemWriter"
                       processor="creditBillProcessor" commit-interval="2"><!--处理步骤为先reader读取文件数据，processor负责处理每一行数据，writer将处理的数据写入到文件-->
                </batch:chunk>
            </batch:tasklet>
        </batch:step>
        <!--<batch:split id=""></batch:split>--> <!--定义并行的step步-->
        <!--<batch:flow id="" parent=""></batch:flow>--> <!--引用独立配置的作业步流程-->
        <!--<batch:decision id="" decider=""></batch:decision>--><!--Step执行的条件判断-->
        <batch:listeners merge="true"><!--多个监听器执行顺序从上到下，before方法按照顺序执行，after方法相反的顺序,merge="true"会对父类子类的拦截器进行合并，相反子类定义的会覆盖掉父类的-->
            <!--<batch:listener ref="systemOut" />-->
            <batch:listener ref="systemOutJobExecutionListener" />
        </batch:listeners><!--定义Job执行时的拦截器-->
        <batch:validator ref="validatorTset"></batch:validator><!--定义JobParamenters 的验证器-->

    </batch:job>

    <!--自定义拦截器-->
    <bean class="org.haijun.study.listener.SystemOutJobExecutionListener" id="systemOutJobExecutionListener" />
    <bean class="org.haijun.study.listener.SystemOut" id="systemOut" />

    <!--参数检验 不存在必须的参数名返回异常，如果超出下面的参数也会报错-->
    <bean class="org.springframework.batch.core.job.DefaultJobParametersValidator" id="validatorTset">
        <property name="requiredKeys"><!--定义必须输入的参数-->
            <set>
                <value>jobInstanceKey</value>
                <value>inputResourse</value>
            </set>
        </property>
        <property name="optionalKeys"><!--可选参数列表-->
            <set>
                <value>name</value>
                <!--<value type="java.lang.Long">23</value>
                <value type="java.lang.Double">31</value>-->
            </set>
        </property>
    </bean>

    <!-- 读取信用卡账单文件,CSV格式 -->
    <!--配置读数据 从文件系统，数据库，队列读取Item（一条数据记录）-->
    <!--scope="step" IOC容器在对象进入相应的Scope之前生成并装配这些对象，在该对象不再处于Scope的限定范围之后，容器通常会销毁这些对象，scope="step" 作业范围在执行的step步-->
    <bean id="csvItemReader" class="org.springframework.batch.item.file.FlatFileItemReader" scope="step">
        <!--定义要读取的文件资源，硬编码方式-->
        <!--<property name="resource" value="classpath:job/ch02/data/credit-card-bill-201303.csv"/>-->
        <!--<property name="resource" value="classpath:jobTestData/jobData1.csv" />-->
        <!--通过确定 scope="step"，可以支持属性的Late Binging（属性后绑定）的能力。绑定对象包含：1.jobParameters(作业参数)，
                                2 . job/stepExecutionContext(当前job/step的执行器上下文)-->
        <property name="resource" value="#{jobParameters['inputResourse']}"/>

        <!--每行数据映射操作配置-->
        <property name="lineMapper" ref="defaultLineMapper" />
    </bean>
    <bean id="defaultLineMapper" class="org.springframework.batch.item.file.mapping.DefaultLineMapper">
        <property name="lineTokenizer" ref="lineTokenizer"/>
        <property name="fieldSetMapper">
            <bean class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
                <property name="prototypeBeanName" value="creditBill"> <!--属性映射的类名-->
                </property>
            </bean>
        </property>
    </bean>

    <!-- lineTokenizer -->
    <bean id="lineTokenizer"
               class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
        <property name="delimiter" value=","/> <!--每行数据分隔符-->
        <property name="names"><!--映射到实体bean属性名称-->
            <list>
                <value>accountID</value>
                <value>name</value>
                <value>amount</value>
                <value>date</value>
                <value>address</value>
            </list>
        </property>
    </bean>

    <!-- 写信用卡账单文件，CSV格式, 该文件会创建生成 -->
    <!--配置写数据 将Item（一条数据记录）写入到数据库，文件系统，队列等-->
    <bean id="csvItemWriter"
               class="org.springframework.batch.item.file.FlatFileItemWriter" scope="step">
        <!--定义要写入的文件-->
        <property name="resource" value="file:target/ch02/outputFile.csv"/>
        <!--<property name="resource" value="classpath:jobTestData/outputFile.csv" />-->
        <!--每行数据转成文件的规则-->
        <property name="lineAggregator">
            <bean class="org.springframework.batch.item.file.transform.DelimitedLineAggregator">
                <property name="delimiter" value=","></property><!--写入时，文本每行数据字段之间使用的分隔符-->
                <property name="fieldExtractor">
                    <bean class="org.springframework.batch.item.file.transform.BeanWrapperFieldExtractor">
                        <property name="names" value="accountID,name,amount,date,address"><!--要转换输出数据属性的名称-->
                        </property>
                    </bean>
                </property>
            </bean>
        </property>
    </bean>
    <!--注入 创建中间处理器 对读到写的对象模型 -->
    <bean id="creditBill" scope="prototype" class="org.haijun.study.model.bo.CreditBill"></bean>
    <!--配置批处理操作，在写之前对数据进行处理，例如数据清洗，数据转换，数据过滤，数据校验 等-->
    <bean id="creditBillProcessor" scope="step" class="org.haijun.study.processor.CreditBillProcessor">
    </bean>
</beans>