# 配置参考http://www.quartz-scheduler.org/documentation/quartz-2.x/configuration/
#         配置主计划程序设置，下面配置非必须配置
#默认值QuartzScheduler，非必须设置，类型字符串，使用多个实例时区分调度程序的机制。如果使用群集功能，则必须对群集中“逻辑上”为同一个调度程序的每个实例使用相同的名称。
org.quartz.scheduler.instanceName = QuartzScheduler

#默认值NON_CLUSTERED，非必须设置，类型字符串，对于所有调度程序必须是唯一的，如果希望为您生成Id，可以使用值AUTO，如果您希望值来自系统属性可以使用值SYS_PROP。
org.quartz.scheduler.instanceId = NON_CLUSTERED

#默认值org.quartz.simpl.SimpleInstanceIdGenerator 非必需，类型字符串，可以实现InstanceIdGenerator自己生成方式。
#instanceId设置为“AUTO”时使用。默认为“org.quartz.simpl.SimpleInstanceIdGenerator”，它根据主机名和时间戳生成实例ID。
#希望值来自系统属性可以使用值SYS_PROP，则使用 SystemPropertyInstanceIdGenerator或者HostnameInstanceIdGenerator使用本地主机名（InetAddress.getLocalHost（。getHostName（））
org.quartz.scheduler.instanceIdGenerator.class = org.quartz.simpl.SimpleInstanceIdGenerator

#默认值 instanceName+ '_QuartzSchedulerThread'，非必需，类型字符串，java线程的有效名称。如果未指定此属性，则线程将接收调度程序的名称以及附加的字符串“_QuartzSchedulerThread”
org.quartz.scheduler.threadName = instanceName+ '_QuartzSchedulerThread'

#默认false，指定调度程序的主线程是否应该是守护程序线程，具体参阅 下面的 配置ThreadPool设置
org.quartz.scheduler.makeSchedulerThreadDaemon = false

#默认false ，指定Quartz生成的线程是否将继承初始化线程的上下文ClassLoader（初始化Quartz实例的线程），将此值设置为“true”可能有助于类加载，JNDI查找以及与在应用程序服务器中使用Quartz相关的其他问题。
org.quartz.scheduler.threadsInheritContextClassLoaderOfInitializer = false

#默认 long 30000 ，是调度程序在空闲时重新查询可用触发器之前等待的时间量（以毫秒为单位）。通常情况下，您不必“调整”此参数，除非您正在使用XA事务，
org.quartz.scheduler.idleWaitTime = 30000

#默认值 long 15000，是调度程序在检测到JobStore内部连接丢失（例如数据库）时重试之间等待的时间量（以毫秒为单位）。使用RamJobStore时，此参数显然没有多大意义。
org.quartz.scheduler.dbFailureRetryInterval = 15000

#默认值org.quartz.simpl.CascadingClassLoadHelper，默认为最强大的方法，即使用“org.quartz.simpl.CascadingClassLoadHelper”类 - 它依次使用其他所有ClassLoadHelper类，直到一个工作。
org.quartz.scheduler.classLoadHelper.class = org.quartz.simpl.CascadingClassLoadHelper

#默认值org.quartz.simpl.SimpleJobFactory；您可以尝试'org.quartz.simpl.PropertySettingJobFactory'。JobFatcory负责生成JobClasses的实例。SimpleJobFactory只是在类上调用newInstance（）。
# PropertySettingJobFactory也可以，但也可以使用SchedulerContext（自2.0.2开始）和Job和Trigger JobDataMaps的内容反射性地设置作业的bean属性。
org.quartz.scheduler.jobFactory.class = org.quartz.simpl.SimpleJobFactory

#默认值none；表示将作为字符串放入“调度程序上下文”的名称 - 值对。例如，设置“org.quartz.context.key.MyKey = MyValue”将执行scheduler.getContext（）。put（“MyKey”，“MyValue”）的等效操作。
org.quartz.context.key.SOME_KEY = none

#默认值java:comp/UserTransaction，除非您使用JTA事务，否则应将事务相关属性排除在配置文件之外。应设置为Quartz可以找到Application Server的UserTransaction管理器的JNDI URL。
#默认几乎适用于所有应用程序服务器。Websphere用户可能需要将此属性设置为“jta / usertransaction”。仅在Quartz配置为使用JobStoreCMT且org.quartz.scheduler.wrapJobExecutionInUserTransaction设置为true时使用。
org.quartz.scheduler.userTransactionURL = java:comp/UserTransaction

#默认false，是否开启作业上调用execute之前启动UserTransaction。如果设置为“true”。在作业的execute方法完成之后，以及JobDataMap更新之后（如果它是StatefulJob），Tx将提交。默认值为“false”。
org.quartz.scheduler.wrapJobExecutionInUserTransaction = false

#默认false，是否跳过运行快速Web请求以确定是否有可供下载的Quartz的更新版本。如果检查运行，并且找到更新，则会在Quartz的日志中报告该更新。
org.quartz.scheduler.skipUpdateCheck = false

#默认值 int的1；允许调度程序节点一次获取（用于触发）的最大触发器数。默认值为1.数字越大，触发效率越高（在需要同时触发很多触发器的情况下） - 但代价是群集节点之间可能存在不平衡负载。
org.quartz.scheduler.batchTriggerAcquisitionMaxCount = 1

#默认值 long类型0；在计划的触发时间之前允许获取和触发触发器的时间量（以毫秒为单位）。数字越大，批量获取触发器的可能性就越大，
org.quartz.scheduler.batchTriggerAcquisitionFireAheadTimeWindow = 0

#      配置ThreadPool设置

#默认空值 ，必须设置，字符串（类名），是您要使用的ThreadPool实现的名称。Quartz附带的线程池是“org.quartz.simpl.SimpleThreadPool”，应该满足几乎每个用户的需求。它具有非常简单的行为，
#并且经过了很好的测试。它提供了一个固定大小的线程池，它们在调度程序的生命周期中“存在”。
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
#默认值int类型 -1，可以是任何正整数，但您应该意识到只有1到100之间的数字是非常实用的。只有一些工作每天开几次，那么1个线程就足够了！如果你有成千上万的工作，每分钟都有很多工作，那么你可能想要一个更像50或100的线程数
org.quartz.threadPool.threadCount = -1
# 默认为 int 类型的5 ；可以是Thread.MIN_PRIORITY（1）和Thread.MAX_PRIORITY（10）之间的任何int 。
org.quartz.threadPool.threadPriority = 5
# 默认false；可以设置为“true”以将池中的线程创建为守护程序线程。默认为“false”。另请参见上面主配置org.quartz.scheduler.makeSchedulerThreadDaemon属性是否也为true。
org.quartz.threadPool.makeThreadsDaemons = false
#可以是“true”或“false”，命名属性来反射性地设置属性，默认为true。通过Of关键字设置线程初始化（InitializingThread）的threadsInheritGroup值
org.quartz.threadPool.threadsInheritGroupOfInitializingThread = false

#    配置全局侦听器
#配置全局TriggerListener（配置全局JobListener类似triggerListener修改成jobListener，还可以配置插件，关键字修改成plugin），NAME替换成下具体的处理
org.quartz.triggerListener.NAME.class = com.foo.MyListenerClass
org.quartz.triggerListener.NAME.propName = propValue
org.quartz.triggerListener.NAME.prop2Name = prop2Value

#    配置调度程序插件之系统默认插件
# 日志记录触发器历史插件捕获触发器事件
org.quartz.plugin.triggHistory.class = org.quartz.plugins.history.LoggingTriggerHistoryPlugin
org.quartz.plugin.triggHistory.triggerFiredMessage = Trigger {1}.{0} fired job {6}.{5} at: {4, date, HH:mm:ss MM/dd/yyyy}
org.quartz.plugin.triggHistory.triggerCompleteMessage = Trigger {1}.{0} completed firing job {6}.{5} at {4, date, HH:mm:ss MM/dd/yyyy}
#shutdown-hook插件捕获JVM终止事件，并在调度程序上调用shutdown。
org.quartz.plugin.shutdownhook.class = org.quartz.plugins.management.ShutdownHookPlugin
org.quartz.plugin.shutdownhook.cleanShutdown = true
#作业初始化插件从XML文件中读取一组作业和触发器，并在初始化期间将它们添加到调度程序。它还可以删除现有数据。有关更多详细信息，请参阅类的JavaDoc。
org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.XMLSchedulingDataProcessorPlugin
# xml数据规范参考http://www.quartz-scheduler.org/xml/job_scheduling_data_1_8.xsd
org.quartz.plugin.jobInitializer.fileNames = data/my_job_data.xml
org.quartz.plugin.jobInitializer.failOnFileNotFound = true

#########################################   存储存储器 的配置 start ####################################################
#      配置RAMJobStore(RAMJobStore用于存储存储器内的调度信息（作业，触发器和日历）。RAMJobStore快速且轻量级，但是当进程终止时，所有调度信息都会丢失。)
org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore
#在被视为“失火”之前，调度程序将“容忍”触发器通过其下一次触发时间的毫秒数。默认值（如果您未在配置中输入此属性）为60000（60秒）。
org.quartz.jobStore.misfireThreshold = 60000


#     配置JDBC-JobStoreTX（JDBCJobStore用于在关系数据库中存储调度信息（作业，触发器和日历），在应用程序未使用JTA事务的情况下在servlet容器中使用，则JDBCJobStore是合适的。）
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
# 默认空值，驱动程序代表了解各种数据库系统的特定“方言”。org.quartz.impl.jdbcjobstore.StdJDBCDelegate（适用于完全符合JDBC的驱动程序，一般够），特定的在org.quartz.impl.jdbcjobstore包下找
org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
#默认空值，此属性的值必须是配置属性文件中定义的DataSource的名称，一般配置就叫dataSource
org.quartz.jobStore.dataSource = dataSource
#默认QRTZ_；JDBCJobStore的“表前缀”属性是一个字符串，它等于在数据库中创建的Quartz表的前缀。如果使用不同的表前缀，您可以在同一数据库中拥有多组Quartz表。
org.quartz.jobStore.tablePrefix = QRTZ_
#默认false，“use properties”标志指示JDBCJobStore JobDataMaps中的所有值都是字符串，因此可以存储为名称 - 值对，而不是在BLOB列中以序列化形式存储更复杂的对象。
org.quartz.jobStore.useProperties = false
#默认int 60000，在触发时间，程序被错过执行，调度程序将“容忍”触发器通过其下一次触发时间的毫秒数
org.quartz.jobStore.misfireThreshold = 60000
#默认false，设置为“true”以打开群集功能。如果您有多个Quartz实例使用相同的数据库表集，则此属性必须设置为“true”...否则您将遭受严重破坏。
org.quartz.jobStore.isClustered = true
#默认 long 15000；设置此实例“签入”*与群集的其他实例的频率（以毫秒为单位）。影响检测失败实例的速度。
org.quartz.jobStore.clusterCheckinInterval = 15000
#默认 int 20；jobstore在给定传递中将处理的最大错误触发器数。一次处理许多（超过几十个）可能会导致数据库表被锁定足够长的时间，从而可能会阻碍触发其他（尚未失实的）触发器的性能。
org.quartz.jobStore.maxMisfiresToHandleAtATime = 20
#默认false；将此参数设置为“true”会告诉Quartz不要在从DataSource获取的连接上调用setAutoCommit（false）
org.quartz.jobStore.dontSetAutoCommitFalse = false
#默认SELECT * FROM {0} LOCKS SCHERE_NAME = {1} AND LOCK_NAME =？FOR UPDATE，必须是一个SQL字符串，用于选择“LOCKS”表中的行并对该行进行锁定。适用于大多数数据库。配置的TABLE_PREFIX替换“{0}”。“{1}”将替换为调度程序的名称。
org.quartz.jobStore.selectWithLockSQL = SELECT * FROM {0} LOCKS WHERE SCHED_NAME = {1} AND LOCK_NAME =？FOR UPDATE
#默认false，值“true”告诉Quartz（使用JobStoreTX或CMT时）在JDBC连接上调用setTransactionIsolation（Connection.TRANSACTION_SERIALIZABLE）。这有助于防止高负载下某些数据库的锁定超时和“持久”事务。
org.quartz.jobStore.txIsolationLevelSerializable = false
#默认false；获取下一个触发器是否应该在显式数据库锁中发生。这曾经是必要的（在Quartz的早期版本中）以避免与特定数据库的死锁，但不再被认为是必要的，因此默认值为“false”。
org.quartz.jobStore.acquireTriggersWithinLock = false
#默认空值；用于生成org.quartz.impl.jdbcjobstore.Semaphore实例的类名，用于锁定对作业存储数据的控制。默认情况下，Quartz将选择最合适的（预先捆绑的）Semaphore实现来使用。MS SQL Server可以配置下
org.quartz.jobStore.lockHandler.class = org.quartz.impl.jdbcjobstore.UpdateLockRowSemaphore
#默认空值，管道分隔的属性列表（及其值），可在初始化期间传递给DriverDelegate。（settingName = settingValue | otherSettingName = otherSettingValue | ...）
org.quartz.jobStore.driverDelegateInitString = settingName = settingValue | otherSettingName = otherSettingValue 

#  配置JDBC-JobStoreCMT（使用Quartz的应用程序管理的事务。JobStoreCMT实际上需要使用两个数据源 - 一个具有由应用程序服务器管理的连接事务（通过JTA）和一个具有不参与全局（JTA）事务的连接的数据源。支持JTA事务
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreCMT
#大部分配置和上面的JDBC-JobStoreTX一样。下面就贴出不一样的
# 默认空值，JobStoreCMT 需要（第二个）数据源，其中包含不属于容器管理事务的连接。此属性的值必须是配置属性文件中定义的DataSource的名称。
# 此数据源必须包含非CMT连接，或者换句话说，对于Quartz直接调用commit（）和rollback（）的连接。
org.quartz.jobStore.nonManagedTXDataSource
#默认false；与属性org.quartz.jobStore.dontSetAutoCommitFalse相同，但它适用于nonManagedTXDataSource。
org.quartz.jobStore.dontSetNonManagedTXConnectionAutoCommitFalse
# 默认false；设置为“true”时，此属性告诉Quartz 在非托管JDBC连接上调用
org.quartz.jobStore.txIsolationLevelReadCommitted


#    可以通过三种方式配置DataSource （org.quartz.dataSource.NAME.driver  name最后就是数据源的名字NAME
org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriver
org.quartz.dataSource.myDS.URL = jdbc：oracle：thin：@ 10.0.1.23：1521：demodb
org.quartz.dataSource.myDS.user = myUser
org.quartz.dataSource.myDS.password = myPassword
org.quartz.dataSource.myDS.maxConnections = 30
#第二种 Application Server引用的数据源示例
org.quartz.dataSource.myOtherDS.jndiURL = JDBC / myDataSource
org.quartz.dataSource.myOtherDS.java.naming.factory.initial = com.evermind.server.rmi.RMIInitialContextFactory
org.quartz.dataSource.myOtherDS.java.naming.provider.url = ormi：// localhost
org.quartz.dataSource.myOtherDS.java.naming.security.principal = admin
org.quartz.dataSource.myOtherDS.java.naming.security.credentials = 123
#第三种 自定义ConnectionProvider实现
org.quartz.dataSource.myCustomDS.connectionProvider.class = com.foo.FooConnectionProvider
org.quartz.dataSource.myCustomDS.someStringProperty = someValue
org.quartz.dataSource.myCustomDS.someIntProperty = 5


#     配置调度程序RMI设置（没有主要属性是必需的，并且都具有“合理的”默认值。当通过RMI使用Quartz时，需要启动Quartz实例，并将其配置为通过RMI“导出”其服务。）
# 到处服务器不开启，如果您希望Quartz Scheduler通过RMI作为服务器导出自身，则将'rmi.export'标志设置为true。
org.quartz.scheduler.rmi.export = false
#可以找到RMI注册表的主机
org.quartz.scheduler.rmi.registryHost = localhost
#RMI注册表正在侦听的端口
org.quartz.scheduler.rmi.registryPort = 1099
#根据您希望Quartz如何创建RMI注册表来设置'rmi.createRegistry'标志,如果您不希望Quartz创建注册表（例如，如果您已经运行了外部注册表），请使用“false”或“never”。
#如果您希望Quartz首先尝试使用现有注册表，然后再回到创建注册表，请使用“true”或“as_needed”。如果希望Quartz尝试创建注册表，然后再使用现有注册表，请使用“always”。
#如果创建了注册表，它将绑定到给定'org.quartz.scheduler.rmi.registryPort'属性中的端口号，'org.quartz.rmi.registryHost'应该是“localhost”。
org.quartz.scheduler.rmi.createRegistry = never
#Quartz Scheduler服务将绑定并侦听连接的端口。默认情况下，RMI服务将“随机”选择一个端口，因为调度程序绑定到RMI注册表。
org.quartz.scheduler.rmi.serverPort = random
#如果要连接（使用）远程服务的调度程序，请将“org.quartz.scheduler.rmi.proxy”标志设置为true。您还必须为RMI注册表进程指定主机和端口 - 通常是“localhost”端口1099。
org.quartz.scheduler.rmi.proxy = false
