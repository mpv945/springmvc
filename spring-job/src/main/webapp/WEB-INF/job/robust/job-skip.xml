<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:batch="http://www.springframework.org/schema/batch"
       xsi:schemaLocation="
       http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!--job健壮性-->
    <!--
    Skip 跳过错误的记录行，保证Job能够正常的执行；适应于非致命的异常；面向chunk的step
    Retry重试给定的操作，比如短暂的网路异常，并发异常等；适用于短暂的异常，经过重试不再重现； 面向Chunk的step或者应用代码
    Restart Job失败后，重新启动Job实例；适应因异常，错误导致Job失败后，可以重新再次启动Job-->

    <!--Step执行期间read，process，write发送的任何异常都会导致step执行失败，进而导致Job作业的失败，通过跳过非致命异常可以让任务继续运行-->
    通过框架定义属性配置Skip
    <batch:job id="skipJob">
        <batch:step id="skipStep">
            <tasklet>
                <chunk reader="reader" processor="processor" writer="writer"
                       commit-interval="1" skip-limit="20">1.skip-limit 配置跳过限制的次数，大于跳过限制次数再发生异常会导致job失败，当错误太多会导致后续手工操作太多，一般指定较小数字
                    <skippable-exception-classes>定义跳过的异常类策略，异常跳过针对read，processor，writer都能发现异常跳过，
                        <include class="java.lang.RuntimeException" />include表示发生该异常系统会跳过
                        <exclude class="java.io.FileNotFoundException" />exclude 表示跳过处理不会针对该异常，这样会交框架处理异常，就会导致job失败
                    </skippable-exception-classes>
                </chunk>
            </tasklet>
        </batch:step>
    </batch:job>
    默认的属性配置跳过不能满足，可以通过自定义跳过策略配置Skip，根据策略判断是否允许跳过异常
    <batch:job id="skipPolicyJob">
        <batch:step id="skipPolicyStep">
            <tasklet>
                <chunk reader="reader" processor="processor"  writer="writer"
                       commit-interval="2" skip-policy="alwaysSkipPolicy">skip-policy指定跳过策略
                </chunk>
            </tasklet>
        </batch:step>
    </batch:job>
    <!--跳过策略-->
    跳过策略实现SkipPolicy接口的shouldSkip方法。默认实现有
        AlwaysSkipItemSkipPolicy 发生任何异常都会导致跳过记录处理
        CompositeSkipPolicy 组合过滤器策略，可以将多个跳过策略组合在一起使用，按着顺序判断是否应该跳过该记录
        ExceptionClassifierSkipPolicy 为不同的异常路由到不同的策略
        LimitCheckingItemSkipPolicy 根据设定的跳过最大次数和异常是否被跳过处理，系统属性配置就用该策略
        NeverSkipItemSkipPolicy 发生任何异常都不会跳过，直接让框架处理结束job
    <bean id="alwaysSkipPolicy" class="org.springframework.batch.core.step.skip.AlwaysSkipItemSkipPolicy"/>
    <!--读实现-->
    <bean id="reader" class="org.haijun.study.robust.skip.AutoReader" >
        <property name="maxCount" value="100" />
    </bean>
    <!--写自定义实现-->
    <bean id="writer" class="org.haijun.study.robust.skip.ConsoleWriter" />
    <!--随机数，参数异常的处理-->
    <bean id="processor" class="org.haijun.study.robust.skip.RadomExceptionItemProcessor" />

    通过配置异常跳过机制，增加跳过监听来记录跳过的数据记录持久化，方便后面追踪
    <batch:job id="dbSkipJob">
        <batch:step id="dbSkipStep">
            <tasklet>
                <chunk reader="radomExceptionAutoReader" processor="processor2" writer="writer2"
                       commit-interval="5" skip-limit="20">
                    <skippable-exception-classes>
                        <include class="org.springframework.batch.item.file.FlatFileParseException" />
                    </skippable-exception-classes>
                    <!--跳过监听-->
                    <listeners>
                        <listener ref="dbSkipListener"></listener>
                    </listeners>
                </chunk>
            </tasklet>
        </batch:step>
    </batch:job>
    <!--跳过监听，使用jdbc做持久化跳过的记录-->
    <bean id="dbSkipListener" class="org.haijun.study.robust.skip.DBSkipListener" >
        <property name="jdbcTemplate" ref="jdbcTemplate"></property>
    </bean>
    <!--会发生异常的读取组件，模拟异常-->
    <bean id="radomExceptionAutoReader"
               class="org.haijun.study.robust.skip.RadomExceptionAutoReader" />
    <bean id="processor2"
               class="org.springframework.batch.item.support.PassThroughItemProcessor" />
    <bean id="writer2"
               class="org.haijun.study.robust.skip.ConsoleWriter" />
    <bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate">
        <constructor-arg ref="dataSource"/>
        <!--<property name="dataSource" value="dataSource"></property>-->
    </bean>
</beans>